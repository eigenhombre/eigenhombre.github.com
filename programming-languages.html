<head><title>Programming Languages</title><link href="tufte-css/tufte.css" rel="stylesheet" /><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><h1>Programming Languages</h1><p class="subtitle"><a href="about-me.html">John Jacobsen</a></p><div><p><figure><a href="img/koans.jpg"><img src="img/koans.jpg" /></a><figcaption>Working on Clojure Koans while riding on a C-17,
     bound for Antarctica</figcaption></figure></p><p>Today I am inspired to ponder many languages at once and review
     which ones I use regularly, which ones I&rsquo;m curious about, which
     ones I avoid, and what I&rsquo;d like to use, if it were to exist.</p><p><h2>Programming Languages I Use Regularly</h2><p><h3>Python</h3><p>By far the language I use most for work. I like it for its
         clean philosophy, its expressiveness, its &ldquo;batteries
         included&rdquo; extensive set of libraries, and, first and
         foremost, for its readability.</p></p><p><h3>C</h3><p><span>Of all the languages I use regularly, C is the one I
         learned first. I maintain a large Linux kernel device driver
         I wrote for the <a href="http://icecube.wisc.edu">IceCube project</a> as well as an embedded system written for 5000+ sensors
         designed for the same.</span></p><p>C now feels like assembly language to me but I still
         appreciate its power and elegance.</p></p><p><h3>Clojure</h3><p><span>I have dabbled in Lisp since the 1980s but not seriously
         until recently. Somewhat seduced by Paul Graham&rsquo;s <a href="http://www.paulgraham.com/avg.html">essays on Lisp</a> and encouraged by a bit of a Lisp renaissance, I have
         started reading up on Clojure and working through problems on <a href="http://4clojure.com">4clojure.com</a>. While not without its warts, I like many things
         about Clojure, including the Lisp &ldquo;code-as-data&rdquo; philosophy,
         availability of macros (something I wish Python had) and its
         interoperability with Java classes. While I doubt I&rsquo;ll be
         able to use this in my paying work any time soon, I have
         started playing with Clojure for personal projects.Having to deal with significantly concurrent systems in my
         work, I am intrigued by functional programming, as opposed to
         the usual object-oriented approaches where state is king and
         where tangled hierarchies of relatively meaningless
         relationships can obscure intent<span><label class="margin-toggle sidenote-number" for="G__18183"></label><input class="margin-toggle" id="G__18183" type="checkbox" /><span class="sidenote">See S. Yegge, <a href="http://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html">The Kingdom of the Nouns</a>.</span></span>. Clojure takes an interesting approach, with its
         emphasis on immutability, software-transactional memory and
         other concurrency primitives.</span></p></p><p><h3>Bash / Unix Tools</h3><p>It amuses me slightly to include bash here, but combining
         simple iteration with conditional statements and adding basic
         Unix concepts and tools such as pipelines, grep, awk, sed,
         wc, etc. is surprisingly powerful. Every small Bash trick or
         new tiny-Unix-tool I learn seems to eliminate the need for
         some number of actual programs, at least for quick-and-dirty
         work. The results tend to be obscure and hard to parse; if I
         can do something in a single line of bash, I will; otherwise
         I&rsquo;ll resort to Python for most things.</p></p><p><h3>Javascript / Coffeescript</h3><p><span>Not my favorite language by any stretch, but you can&rsquo;t
         avoid it if you&rsquo;re working in the browser (I don&rsquo;t consider
         closed-source Flash an option). The language has a lot of
         warts, but some <a href="http://www.amazon.com/JavaScript-Good-Parts-Douglas-Crockford/dp/0596517742">good parts</a> too. I can feel the Lisp bones
         deep underneath the surface of the language when I dive into
         JavaScript. CoffeeScript is sweet because it&rsquo;s so much more
         readable and offers protection from common JavaScript
         gotchas, but has <a href="http://lucumr.pocoo.org/2011/12/22/implicit-scoping-in-coffeescript/">some flaws of its own</a>.</span></p></p></p><p><h2>Programming Languages I Have Used in the Past but
                  Tend to Avoid</h2><p><h3>Perl</h3><p>I fell in love with the power of Perl (&ldquo;the duct-tape of the
         Internet&rdquo;) back in the 1990s, but now dislike its strange,
         ad-hoc syntax and the relative inscrutability when compared
         to Python.</p></p><p><h3>Java</h3><p><span>I haven&rsquo;t done a ton of Java development, but have done
         enough to be irritated by certain things about it: its
         extremely verbose syntax, strict typing, distance from the
         actual hardware, and lack of (at least until now) anonymous
         functions (&ldquo;lambda&rdquo;). Also the JVM startup time is
         irritating, a problem Clojure inherits from Java (though
         <a href="https://github.com/ninjudd/drip">there are
          workarounds</a>).</span></p><p>Java has become so ubiquitous, however, that it&rsquo;s hard to
          avoid, and it does have a certain self-consistent
          habitability to it. I think current JVM languages such as
          Clojure and Scala will only strengthen the role of Java and
          the JVM in modern computing, unless Oracle massively screws
          things up.</p></p><p><h3>C++</h3><p>Another language I&rsquo;ve played with a bit. A language that
         splits the difference between C and Java (I realize C++ came
         before Java); I would prefer to write in a &ldquo;real&rdquo; higher
         level language and glue C in where needed.</p></p><p><h3>FORTRAN</h3><p>I&rsquo;m sorry to say that, coming from physics, I&rsquo;ve written
         more FORTRAN code than I care to admit. I find it
         interesting, however, that while Lisp and FORTRAN are almost
         the same age, Lisp still holds interest where FORTRAN does
         not (except to pure number-crunchers, due to ancient and
         venerable numeric libraries).</p></p></p><p><h2>Languages I&rsquo;m Curious About But Haven&rsquo;t Had Time to
                  Look At Much</h2><p>Exposure to purely functional programming and lazy evaluation
        in Clojure made me curious about Haskell.</p><p>I am curious about Erlang, which is supposed to have excellent
        concurrency features.</p><p>I saw some talks about Go at
        OSCON. Go looks like it has some really nice features compared
        to C (compilation speed, concurrency support, and improved
        readability), but it may be a bit low-level for my interests.</p><p>I have only tinkered with Objective-C, but that is the
        language of choice for serious Mac OS X or iOS
        development. Its syntax looks pretty odd, but perhaps that&rsquo;s a
        small price to pay for running on all that pretty hardware.  </p><p>Purely logical languages such as Prolog (equivalents of
        which can be easily implemented in Lisp) are of interest for
        their ability to process large amount of semantically-related
        content. I&rsquo;m curious about expert systems, ontologies, the
        Semantic Web, and many other related areas of AI
        research.</p></p><p><h2>The Language I Wish Existed</h2><p> The perfect language would:</p><p><ol><li>Be very readable, like Python (whitespace or other
        visual cues probably playing a significant role)</li><li>Support full Lisp-like macros (&ldquo;homoiconicity&rdquo;)</li><li>Have very broad library support (Python, Java, &hellip;)</li><li>Have built-in features in support of test-driven
        development (Python&rsquo;s doctests and Clojure&rsquo;s <code>:test</code> metadata
        seem like just the beginning of what might be possible)</li><li>Handle concurrency very well (Clojure, Erlang, &hellip; but not Python)</li><li>Run in the browser, or be implemented efficiently on top
        of JavaScript</li><li>Allow you to get very close to the machine if necessary,
        or at least the bytecodes of the virtual machine or
        interpreter (Python, C, C++, &hellip;)</li></ol></p><p>Points 1-3 are the most important to me. Resolving the tension
       between points 1 and 2 is of particular interest.</p><p><span>I doubt such a language will come along any time soon. But I&rsquo;m
       taking <a href="http://www.dabeaz.com/chicago/compiler.html">a class
       next month</a> which, who knows? &hellip; might help someday.</span></p></p></div><div><p><a href="about-me.html">about</a>|<a href="content.html">all posts</a></p><p>&copy; 2016 <a href="about-me.html">John Jacobsen</a>. Created with <a href="https://github.com/eigenhombre/unmark">unmark</a>.  CSS by <a href="https://edwardtufte.github.io/tufte-css/">Tufte-CSS</a>.</p></div><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-40279882-1']);
_gaq.push(['_trackPageview']);
(function() {
      var ga = document.createElement('script');
      ga.type = 'text/javascript';
      ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www')
               + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; 
      s.parentNode.insertBefore(ga, s);
})();</script></body>