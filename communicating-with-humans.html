<head><title>Communicating With Humans</title><link href="tufte-css/tufte.css" rel="stylesheet" /><script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><h1>Communicating With Humans</h1><p class="subtitle">John Jacobsen</p><div><p><em>If nobody but me likes it, let it die. &mdash; <a href="http://www.informit.com/articles/article.aspx?p=1193856">Knuth</a></em></p><p><figure><a href="img/marg-printed.jpg"><img src="img/marg-printed.jpg" /></a></figure></p><p><span>This is the fifth post in a <a href="/clojure/2014/07/03/an-advanced-clojure-workflow/">series</a> about my Clojure workflow.</span></p><p>When you encounter a new codebase, what best allows you to
   quickly understand it so that you can make effective changes to
   it?</p><p>I switched jobs about six months ago. There was intense
   information transfer both while leaving my old projects behind,
   and while getting up to speed with new ones. I printed out a lot
   of code and read it front-to-back, quickly at first, and then
   carefully. I found this a surprisingly effective way to review
   and learn, compared to my usual way of navigating code on disk
   and in an editor solely on an as-needed basis. </p><p>If this (admittedly old-school) way of understanding a program
   works well, how much better might it work if there was enough
   prose interspersed in amongst the code to explain anything
   non-obvious, and if the order of the text was presented in such
   a way as to aid understanding? </p><p>What is the target audience of computer programs, anyways? It is
   clearly the machines, which have to carry out our insanely
   specific instructions... but, equally clearly, it is also the
   humans who have to read, understand, maintain, fix, and extend
   those programs. It astonishes me now how little attention is
   paid to this basic fact. </p><p><span>In addition to communicating, we also have to <em>think carefully</em> about our work. While not every
      programming problem is so difficult as to merit <a href="https://www.youtube.com/watch?v=f84n5oFoZBc"> a year&rsquo;s worth
      of contemplation</a>, any software system of significant size requires continual
    care, attention, and occasional hard thinking in order to keep
    complexity under control. The best way I know to think clearly
    about a problem is to write about it &#x2013; the harder the
    problem, the more careful and comprehensive the required
    writing. </span></p><p>Writing aids thinking, because it is slower than
   thought... because you can replay thoughts over and over, iterate
   upon and refine them. Because writing is explaining, and because
   explaining something is the best way I know to learn and
   understand it. </p><p><span><a href="http://en.wikipedia.org/wiki/Literate_programming">Literate Programming</a> (LP) was invented by Donald Knuth in the 1980s as a way to
    address some of these concerns. LP has hardcore enthusiasts
    scattered about, but apparently not much traction in the
    mainstream. As I have gotten more experience working with
    complex codebases, and more engaged with the craft or
    programming, I have become increasingly interested in LP as a
    way to write good programs. Knuth takes it further, considering
    the possibility that programs are, or could be, <em>works
    of literature</em>. </span></p><p>Knuth&rsquo;s innovation was both in realizing these possibilities and
   in implementing the first system for LP, called WEB. WEB takes a
   document containing a mix of prose and code and both typesets it
   in a readable (beautiful, even) form for humans, and also orders
   and assembles the program for a compiler to consume. </p><p><span>Descendents and variants of WEB can be found in use
      today. My favorite for Clojure is currently <a href="https://github.com/gdeer81/marginalia">Marginalia</a>,
      originally by Michael Fogus and currently maintained by Gary
      Deer. </span></p><p><span><a href="http://web.archive.org/web/20090102151452/http://www.perl.com/pub/a/tchrist/litprog.html">Purists of LP will disagree</a> that systems like Marginalia, which do not support reordering
    and reassembly of source code, are &ldquo;true&rdquo; Literate
    Programming tools; and, in fact, there is a caveat on the
    Marginalia docs to that effect... but what Marginalia provides
    is good enough for me: </span></p><p><ol><li>Placement of comments and docstrings adjacent to the
      code in question; </li><li>Beautiful formatting of same; </li><li>Support for Markdown/HTML and attachment of JavaScript
      and/or CSS files; therefore, for images, mathematics (via
      MathJax) and graphing (see next blog post). </li></ol></p><p>The result of these capabilities is a lightweight tool which
   lets me take an existing Clojure project and, with very little
   extra effort, generate a Web-based or printed/PDF artifact
   which I can sit down with, learn from, and enjoy contemplating.</p><p><h1>Marginalia in Action:</h1><p><figure><a href="img/marg-screenshot.png"><img src="img/marg-screenshot.png" /></a></figure></p><p><figure><a href="img/emacs-screenshot.png"><img src="img/emacs-screenshot.png" /></a></figure></p></p><p><h1>The Notebook Pattern</h1><p>I often start writing by making simple statements or questions: </p><p><ol><li>I want to be able to do \(X\).... </li><li>I don&rsquo;t understand \(Y\).... </li><li>If we had feature \(P\), then \(Q\) would be easy.... </li><li>How long would it take to compute \(Z\)? </li></ol></p><p><span>Sentences like these are like snippets of code in the
      REPL: things to evaluate and experiment with. Often these
      statements are attached to bits of code &mdash; experimental
      expressions, and their evaluated results. They are the
      building blocks of further ideas, programs, and chains of
      thought. In <a href="/clojure/2014/08/03/marginalia-hacks/">my next post</a>, I&rsquo;ll talk about using Marginalia to make small notebooks
      where I collect written thoughts, code, expression, even
      graphs and plots while working on a problem. This workflow
      involves some Marginalia hacks you may not see elsewhere. </span></p><p>Meanwhile, here are some quotes about LP:</p><p>&ldquo;Instead of writing code containing documentation, the
     literate programmer writes documentation containing
     code.... The effect of this simple shift of emphasis can be so
     profound as to change one&rsquo;s whole approach to programming.&rdquo;
     &mdash;Ross Williams, FunnelWeb Tutorial Manual, p.4. </p><p>&ldquo;Knuth&rsquo;s insight is to focus on the program as a message
     from its author to its readers.&rdquo; &mdash;Jon Bently,
     &ldquo;Programming Pearls,&rdquo; Communications of the ACM, 1986.</p><p><span>&ldquo;... Literate programming is certainly the most
     important thing that came out of the TeX project. Not only
     has it enabled me to write and maintain programs faster and
     more reliably than ever before, and been one of my greatest
     sources of joy since the 1980s&mdash;it has actually been
     indispensable at times. Some of my major programs, such as
     the MMIX meta-simulator, could not have been written with any
     other methodology that I&rsquo;ve ever heard of. The complexity was
     simply too daunting for my limited brain to handle; without
     literate programming, the whole enterprise would have flopped
     miserably.&rdquo; &mdash;Donald Knuth, <a href="http://www.informit.com/articles/article.aspx?p=1193856&amp;rll=1">interview</a>, 2008.</span></p></p></div><div><p><a href="about-me.html">about</a>|<a href="content.html">all posts</a></p><p>&copy; 2015 <a href="about-me.html">John Jacobsen</a>. Created with <a href="https://github.com/eigenhombre/unmark">unmark</a>.  CSS by <a href="https://edwardtufte.github.io/tufte-css/">Tufte-CSS</a>.</p></div><script type="text/javascript">var _gaq = _gaq || [];
_gaq.push(['_setAccount', 'UA-40279882-1']);
_gaq.push(['_trackPageview']);
(function() {
      var ga = document.createElement('script');
      ga.type = 'text/javascript';
      ga.async = true;
      ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www')
               + '.google-analytics.com/ga.js';
      var s = document.getElementsByTagName('script')[0]; 
      s.parentNode.insertBefore(ga, s);
})();</script></body>